// Stripped down ANSI C grammar - 2011 ISO C standard
// Source: http://www.quut.com/c/ANSI-C-grammar-y.html
// Does not support:
// - multiple declarations and initializations (like structs, arrays, inits list)
//   - only simple `identifier = x` or `sizeX_t identifier = x`
// - No `->` operator
// - Loops with only declaration and _expression_statement.
//   They need three _expression_statements in the brackets.
//   Also a declaration as first part is mandatory.
// - std types liek `int`, `float`, `double` etc. Only `sizeX_t`.
// Adds:
// - Range indexing in arrays arr[a:b]
//
// Please note: Assignemnets and initialization declarations can look the same
// since in the manual is sometimes missing. This leads to an ambiguous tree which is handled later.
//

start: fbody
fbody: statement* -> fbody

    ?statement: assembler_statement
        | labeled_statement 
        | compound_statement
        | _expression_statement
        | selection_statement
        | iteration_statement
        | jump_statement

    assembler_statement: "Assembler mapped to: \"" INSTRUCTION_MNEM "\";"

    labeled_statement: identifier ":" statement
        | CASE constant_expression ":" statement
        | DEFAULT ":" statement

    compound_statement: "{" "}"
        | "{" block_item_list "}"

    block_item_list: block_item
        | block_item_list block_item

    block_item: declaration
        | statement

    _expression_statement: ";"
	    | _expression ";"

    selection_statement: IF "(" _expression ")" statement ELSE statement
        | IF "(" _expression ")" statement
        | SWITCH "(" _expression ")" statement

    iteration_statement: WHILE "(" _expression ")" statement
        | DO statement WHILE "(" _expression ")" ";"
        | FOR "(" declaration _expression_statement _expression ")" statement

    jump_statement: GOTO identifier ";"
        | CONTINUE ";"
        | BREAK ";"
        | RETURN ";"
        | RETURN _expression ";"

    _expression: assignment_expression
        | _expression "," assignment_expression

    constant_expression: conditional_expression

    declaration: type_specifier init_declarator ";"
        | init_declarator ";" // Type is not always given.

    init_declarator: identifier "=" initializer

    initializer: assignment_expression

    primary_expression: operand 
        | string
        | "(" _expression ")"

    postfix_expression: primary_expression
        | postfix_expression "[" additive_expression ":" additive_expression "]"
        | postfix_expression "[" _expression "]"
        | postfix_expression "(" ")"
        | postfix_expression "(" argument_expression_list ")"
        | postfix_expression "." identifier | INT
        | postfix_expression INC_OP
        | postfix_expression DEC_OP
    
    argument_expression_list: assignment_expression
	    | argument_expression_list "," assignment_expression

    unary_expression: postfix_expression
        | INC_OP unary_expression
        | DEC_OP unary_expression
        | unary_operator cast_expression

    cast_expression: "(" type_specifier ")" unary_expression
        | unary_expression

    multiplicative_expression: cast_expression
        | multiplicative_expression "**" cast_expression
        | multiplicative_expression "*" cast_expression
        | multiplicative_expression "/" cast_expression
        | multiplicative_expression "%" cast_expression


    additive_expression: multiplicative_expression
        | additive_expression "+" multiplicative_expression
        | additive_expression "-" multiplicative_expression


    shift_expression: additive_expression
        | shift_expression LEFT_OP additive_expression
        | shift_expression RIGHT_OP additive_expression


    relational_expression: shift_expression
        | relational_expression "<" shift_expression
        | relational_expression ">" shift_expression
        | relational_expression LE_OP shift_expression
        | relational_expression GE_OP shift_expression


    equality_expression: relational_expression
        | equality_expression EQ_OP relational_expression
        | equality_expression NE_OP relational_expression


    and_expression: equality_expression
        | and_expression "&" equality_expression


    exclusive_or_expression: and_expression
        | exclusive_or_expression "^" and_expression


    inclusive_or_expression: exclusive_or_expression
        | inclusive_or_expression "|" exclusive_or_expression


    logical_and_expression: inclusive_or_expression
        | logical_and_expression AND_OP inclusive_or_expression


    logical_or_expression: logical_and_expression
        | logical_or_expression OR_OP logical_and_expression


    conditional_expression: logical_or_expression
        | logical_or_expression "?" _expression ":" conditional_expression


    assignment_expression: conditional_expression
        | unary_expression assignment_operator assignment_expression

    ?identifier: operand

    unary_operator: "*"
        | "+"
        | "-"
        | "~"
        | "!"

    assignment_operator: "="
        | MUL_ASSIGN
        | DIV_ASSIGN
        | MOD_ASSIGN
        | ADD_ASSIGN
        | SUB_ASSIGN
        | LEFT_ASSIGN
        | RIGHT_ASSIGN
        | AND_ASSIGN
        | XOR_ASSIGN
        | OR_ASSIGN

    RIGHT_ASSIGN: ">>="
    LEFT_ASSIGN: "<<="
    ADD_ASSIGN: "+="
    SUB_ASSIGN: "-="
    MUL_ASSIGN: "*="
    DIV_ASSIGN: "/="
    MOD_ASSIGN: "%="
    AND_ASSIGN: "&="
    XOR_ASSIGN: "^="
    OR_ASSIGN: "|="
    RIGHT_OP: ">>"
    LEFT_OP: "<<"
    INC_OP: "++"
    DEC_OP: "--"
    PTR_OP: "->"
    AND_OP: "&&"
    OR_OP: "||"
    LE_OP: "<="
    GE_OP: ">="
    EQ_OP: "=="
    NE_OP: "!="
    IF: "if"
    ELSEIF: "else if"
    ELSE: "else"
    FOR: "for"
    WHILE: "while"
    DO: "do"
    SWITCH: "switch"
    RETURN: "return"
    CONTINUE: "continue"
    BREAK: "break"
    GOTO: "goto"
    CASE: "case"
    DEFAULT: "default"

    ?operand: imm
        | INTCON
        | TYPED_INT
        | TLB

    ?imm: any_reg
        | "#" IMMLETT [INT]

    any_reg: hvx_pred
        | GP_REG
        | SYS_REG

    hvx_pred: reg
        | "Q" SRC_REG "V"

    reg: variable
        | REG_TYPE SRC_REG
        | REG_TYPE SRC_REG_PAIR

    variable: /[A-Za-z_]\w*/

    REG_TYPE: "C" | "N" | "P" | "R" | "M" | "Q" | "V" | "O"
    SRC_REG: "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" | "d" | "e" | "f" | "g"
    SRC_REG_PAIR: "ss" | "tt" | "uu" | "vv" | "xx"| "yy" | "zz" | "dd" | "ee" | "ff" | "gg"
    // w = word; h = half word; b = byte; u = unsigned; .s64 signed 64bit
    //SUBFIELD: "uw" | "w" | "uh" | "h" | "ub" | "b" | (("s" | "u") BIT_WIDTH)

    GP_REG: "GP"
    SYS_REG: "PC"

    IMMLETT: /[rRsSuUm]/
    INSTRUCTION_MNEM: /[^"]+/
    TLB: "TLB"
    type_specifier: UT8
        | UT16
        | UT32
        | UT64
        | ST8
        | ST16
        | ST32
        | ST64
    
    UT8: "size8u_t"
    UT16: "size16u_t"
    UT32: "size32u_t"
    UT64: "size64u_t"
    ST8: "size8s_t"
    ST16: "size16s_t"
    ST32: "size32s_t"
    ST64: "size64s_t"

    INT_TYPE: "LL" | "ULL"
    TYPED_INT: INT INT_TYPE
    BIT_WIDTH: "8" | "16" | "32" | "64"
    INTCON: HEX_NUMBER | DEC_NUMBER
    HEX_NUMBER: /0x[\da-f]*/i
    DEC_NUMBER: /0|[1-9][\d_]*/i

    string: ESCAPED_STRING

    %import common.ESCAPED_STRING
    %import common.WORD
    %import common.INT
    %import common.DIGIT
    %import common.SIGNED_NUMBER
    %import common.WS
    %ignore WS