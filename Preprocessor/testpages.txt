Hexagon V67 Programmer’s Reference Manual                                                         Instruction Set
        Compare and jump
                  Compare two registers, or a register and immediate value, and write a predicate with the
                  result. Then use the predicate result to conditionally jump to a PC-relative target address.
                  The registers available as operands are restricted to R0-R7 and R16-R23. The predicate
                  destination is restricted to P0 and P1.
                  In assembly syntax, this instruction appears as two instructions in the packet: a compare
                  and a separate conditional jump. The assembler may convert adjacent compare and jump
                  instructions into compound compare-jump form.
                   Syntax                               Behavior
                   p[01]=cmp.eq(Rs,#-1); if              P[01]=(Rs==-1) ? 0xff : 0x00 if
                   ([!]p[01].new) jump:<hint>            ([!]P[01].new[0]) {
                   #r9:2                                     apply_extension(#r);
                                                             #r=#r & ~PCALIGN_MASK;
                                                             PC=PC+#r;
                                                         }
                   p[01]=cmp.eq(Rs,#U5); if              P[01]=(Rs==#U) ? 0xff : 0x00 if
                   ([!]p[01].new) jump:<hint>            ([!]P[01].new[0]) {
                   #r9:2                                     apply_extension(#r);
                                                             #r=#r & ~PCALIGN_MASK;
                                                             PC=PC+#r;
                                                         }
                   p[01]=cmp.eq(Rs,Rt); if               P[01]=(Rs==Rt) ? 0xff : 0x00 if
                   ([!]p[01].new) jump:<hint>            ([!]P[01].new[0]) {
                   #r9:2                                     apply_extension(#r);
                                                             #r=#r & ~PCALIGN_MASK;
                                                             PC=PC+#r;
                                                         }
                   p[01]=cmp.gt(Rs,#-1); if              P[01]=(Rs>-1) ? 0xff : 0x00 if ([!]P[01].new[0])
                   ([!]p[01].new) jump:<hint>            {
                   #r9:2                                     apply_extension(#r);
                                                             #r=#r & ~PCALIGN_MASK;
                                                             PC=PC+#r;
                                                         }
                   p[01]=cmp.gt(Rs,#U5); if              P[01]=(Rs>#U) ? 0xff : 0x00 if ([!]P[01].new[0])
                   ([!]p[01].new) jump:<hint>            {
                   #r9:2                                     apply_extension(#r);
                                                             #r=#r & ~PCALIGN_MASK;
                                                             PC=PC+#r;
                                                         }
                   p[01]=cmp.gt(Rs,Rt); if               P[01]=(Rs>Rt) ? 0xff : 0x00 if ([!]P[01].new[0])
                   ([!]p[01].new) jump:<hint>            {
                   #r9:2                                     apply_extension(#r);
                                                             #r=#r & ~PCALIGN_MASK;
                                                             PC=PC+#r;
                                                         }
                   p[01]=cmp.gtu(Rs,#U5); if             P[01]=(Rs.uw[0]>#U) ? 0xff : 0x00 if
                   ([!]p[01].new) jump:<hint>            ([!]P[01].new[0]) {
                   #r9:2                                     apply_extension(#r);
                                                             #r=#r & ~PCALIGN_MASK;
                                                             PC=PC+#r;
                                                         }
80-N2040-45 Rev. B                                                                                            227
Hexagon V67 Programmer’s Reference Manual                                                             Instruction Set
                   Syntax                                   Behavior
                   p[01]=cmp.gtu(Rs,Rt); if                 P[01]=(Rs.uw[0]>Rt) ? 0xff : 0x00 if
                   ([!]p[01].new) jump:<hint>               ([!]P[01].new[0]) {
                   #r9:2                                        apply_extension(#r);
                                                                #r=#r & ~PCALIGN_MASK;
                                                                PC=PC+#r;
                                                            }
                   p[01]=tstbit(Rs,#0); if                  P[01]=(Rs & 1) ? 0xff : 0x00 if ([!]P[01].new[0])
                   ([!]p[01].new) jump:<hint>               {
                   #r9:2                                        apply_extension(#r);
                                                                #r=#r & ~PCALIGN_MASK;
                                                                PC=PC+#r;
                                                            }
                  Class: J (slots 0,1,2,3)
                  Encoding
31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9  8 7  6  5 4  3  2 1  0
   ICLASS                                 s4     Parse
                                                                                            p0=cmp.eq(Rs,#-1); if
 0  0  0  1 0  0   0 1  1  0   i  i  s  s    s s P   P 0  -   - - 0  0  i i  i i  i  i i  - (p0.new) jump:nt #r9:2
                                                                                            p0=cmp.gt(Rs,#-1); if
 0  0  0  1 0  0   0 1  1  0   i  i  s  s    s s P   P 0  -   - - 0  1  i i  i i  i  i i  -
                                                                                            (p0.new) jump:nt #r9:2
 0  0  0  1 0  0   0 1  1  0   i  i  s  s    s s P   P 0  -   - - 1  1  i i  i i  i  i i  - p0=tstbit(Rs,#0); if (p0.new)
                                                                                            jump:nt #r9:2
                                                                                            p0=cmp.eq(Rs,#-1); if
 0  0  0  1 0  0   0 1  1  0   i  i  s  s    s s P   P 1  -   - - 0  0  i i  i i  i  i i  -
                                                                                            (p0.new) jump:t #r9:2
                                                                                            p0=cmp.gt(Rs,#-1); if
 0  0  0  1 0  0   0 1  1  0   i  i  s  s    s s P   P 1  -   - - 0  1  i i  i i  i  i i  -
                                                                                            (p0.new) jump:t #r9:2
 0  0  0  1 0  0   0 1  1  0   i  i  s  s    s s P   P 1  -   - - 1  1  i i  i i  i  i i  - p0=tstbit(Rs,#0); if (p0.new)
                                                                                            jump:t #r9:2
                                                                                            p0=cmp.eq(Rs,#-1); if
 0  0  0  1 0  0   0 1  1  1   i  i  s  s    s s P   P 0  -   - - 0  0  i i  i i  i  i i  -
                                                                                            (!p0.new) jump:nt #r9:2
                                                                                            p0=cmp.gt(Rs,#-1); if
 0  0  0  1 0  0   0 1  1  1   i  i  s  s    s s P   P 0  -   - - 0  1  i i  i i  i  i i  -
                                                                                            (!p0.new) jump:nt #r9:2
                                                                                            p0=tstbit(Rs,#0); if
 0  0  0  1 0  0   0 1  1  1   i  i  s  s    s s P   P 0  -   - - 1  1  i i  i i  i  i i  -
                                                                                            (!p0.new) jump:nt #r9:2
 0  0  0  1 0  0   0 1  1  1   i  i  s  s    s s P   P 1  -   - - 0  0  i i  i i  i  i i  - p0=cmp.eq(Rs,#-1); if
                                                                                            (!p0.new) jump:t #r9:2
                                                                                            p0=cmp.gt(Rs,#-1); if
 0  0  0  1 0  0   0 1  1  1   i  i  s  s    s s P   P 1  -   - - 0  1  i i  i i  i  i i  -
                                                                                            (!p0.new) jump:t #r9:2
                                                                                            p0=tstbit(Rs,#0); if
 0  0  0  1 0  0   0 1  1  1   i  i  s  s    s s P   P 1  -   - - 1  1  i i  i i  i  i i  - (!p0.new) jump:t #r9:2
                                                                                            p0=cmp.eq(Rs,#U5); if
 0  0  0  1 0  0   0 0  0  0   i  i  s  s    s s P   P 0  I   I I  I I  i i  i  i i  i i  - (p0.new) jump:nt #r9:2
                                                                                            p0=cmp.eq(Rs,#U5); if
 0  0  0  1 0  0   0 0  0  0   i  i  s  s    s s P   P 1  I   I I  I I  i i  i  i i  i i  -
                                                                                            (p0.new) jump:t #r9:2
                                                                                            p0=cmp.eq(Rs,#U5); if
 0  0  0  1 0  0   0 0  0  1   i  i  s  s    s s P   P 0  I   I I  I I  i i  i  i i  i i  -
                                                                                            (!p0.new) jump:nt #r9:2
 0  0  0  1 0  0   0 0  0  1   i  i  s  s    s s P   P 1  I   I I  I I  i i  i  i i  i i  - p0=cmp.eq(Rs,#U5); if
                                                                                            (!p0.new) jump:t #r9:2
                                                                                            p0=cmp.gt(Rs,#U5); if
 0  0  0  1 0  0   0 0  1  0   i  i  s  s    s s P   P 0  I   I I  I I  i i  i  i i  i i  - (p0.new) jump:nt #r9:2
                                                                                            p0=cmp.gt(Rs,#U5); if
 0  0  0  1 0  0   0 0  1  0   i  i  s  s    s s P   P 1  I   I I  I I  i i  i  i i  i i  - (p0.new) jump:t #r9:2
                                                                                            p0=cmp.gt(Rs,#U5); if
 0  0  0  1 0  0   0 0  1  1   i  i  s  s    s s P   P 0  I   I I  I I  i i  i  i i  i i  -
                                                                                            (!p0.new) jump:nt #r9:2
                                                                                            p0=cmp.gt(Rs,#U5); if
 0  0  0  1 0  0   0 0  1  1   i  i  s  s    s s P   P 1  I   I I  I I  i i  i  i i  i i  -
                                                                                            (!p0.new) jump:t #r9:2
80-N2040-45 Rev. B                                                                                                    228
Hexagon V67 Programmer’s Reference Manual                                                        Instruction Set
        Jump to address condition on register value
                  Perform register-conditional jump.
                  Jump if the specified register expression is true.
                  A register-conditional jump includes a hint ("taken" or "not taken") which specifies the
                  expected value of the register expression. If the actual generated value of the expression
                  differs from this expected value, the jump instruction incurs a performance penalty.
                  This instruction can appear only in slot 3.
                   Syntax                               Behavior
                   if (Rs!=#0) jump:nt #r13:2           if (Rs != 0) {
                                                            PC=PC+#r;
                                                        }
                   if (Rs!=#0) jump:t #r13:2            if (Rs != 0) {
                                                            PC=PC+#r;
                                                        }
                   if (Rs<=#0) jump:nt #r13:2           if (Rs<=0) {
                                                            PC=PC+#r;
                                                        }
                   if (Rs<=#0) jump:t #r13:2            if (Rs<=0) {
                                                            PC=PC+#r;
                                                        }
                   if (Rs==#0) jump:nt #r13:2           if (Rs == 0) {
                                                            PC=PC+#r;
                                                        }
                   if (Rs==#0) jump:t #r13:2            if (Rs == 0) {
                                                            PC=PC+#r;
                                                        }
                   if (Rs>=#0) jump:nt #r13:2           if (Rs>=0) {
                                                            PC=PC+#r;
                                                        }
                   if (Rs>=#0) jump:t #r13:2            if (Rs>=0) {
                                                            PC=PC+#r;
                                                        }
                  Class: J (slot 3)
                  Notes
                       ■   This instruction will be deprecated in a future version.
80-N2040-45 Rev. B                                                                                           234
Hexagon V66 HVX Programmer’s Reference Manual                                                   Instruction Set
                   Syntax                                     Behavior
                   Vd.b=vasr(Vu.h,Vv.h,Rt)[:rnd]:sat          for (i = 0; i < VELEM(16); i++) {
                                                                   shamt = Rt & 0x7;
                                                                   Vd.h[i].b[0]=sat8(Vv.h[i] + (1<<(shamt-
                                                              1)) >> shamt);
                                                                   Vd.h[i].b[1]=sat8(Vu.h[i] + (1<<(shamt-
                                                              1)) >> shamt) ;
                                                              }
                   Vd.h=vasr(Vu.w,Vv.w,Rt):rnd:sat            for (i = 0; i < VELEM(32); i++) {
                                                                   shamt = Rt & 0xF;
                                                                   Vd.w[i].h[0]=sat16(Vv.w[i] + (1<<(shamt-
                                                              1)) >> shamt);
                                                                   Vd.w[i].h[1]=sat16(Vu.w[i] + (1<<(shamt-
                                                              1)) >> shamt) ;
                                                              }
                   Vd.h=vasr(Vu.w,Vv.w,Rt)[:sat]              for (i = 0; i < VELEM(32); i++) {
                                                                   shamt = Rt & 0xF;
                                                                   Vd.w[i].h[0]=[sat16](Vv.w[i] >> shamt);
                                                                   Vd.w[i].h[1]=[sat16](Vu.w[i] >> shamt) ;
                                                              }
                   Vd.ub=vasr(Vu.h,Vv.h,Rt)[:rnd]:sat         for (i = 0; i < VELEM(16); i++) {
                                                                   shamt = Rt & 0x7;
                                                                   Vd.h[i].b[0]=usat8(Vv.h[i] + (1<<(shamt-
                                                              1)) >> shamt);
                                                                   Vd.h[i].b[1]=usat8(Vu.h[i] + (1<<(shamt-
                                                              1)) >> shamt) ;
                                                              }
                   Vd.ub=vasr(Vu.uh,Vv.uh,Rt)[:rnd]:sat for (i = 0; i < VELEM(16); i++) {
                                                                   shamt = Rt & 0x7;
                                                                   Vd.uh[i].b[0]=usat8(Vv.uh[i] +
                                                              (1<<(shamt-1)) >> shamt);
                                                                   Vd.uh[i].b[1]=usat8(Vu.uh[i] +
                                                              (1<<(shamt-1)) >> shamt) ;
                                                              }
                   Vd.uh=vasr(Vu.uw,Vv.uw,Rt)[:rnd]:sat for (i = 0; i < VELEM(32); i++) {
                                                                   shamt = Rt & 0xF;
                                                                   Vd.uw[i].h[0]=usat16(Vv.uw[i] +
                                                              (1<<(shamt-1)) >> shamt);
                                                                   Vd.uw[i].h[1]=usat16(Vu.uw[i] +
                                                              (1<<(shamt-1)) >> shamt) ;
                                                              }
                   Vd.uh=vasr(Vu.w,Vv.w,Rt)[:rnd]:sat         for (i = 0; i < VELEM(32); i++) {
                                                                   shamt = Rt & 0xF;
                                                                   Vd.w[i].h[0]=usat16(Vv.w[i] +
                                                              (1<<(shamt-1)) >> shamt);
                                                                   Vd.w[i].h[1]=usat16(Vu.w[i] +
                                                              (1<<(shamt-1)) >> shamt) ;
                                                              }
                  Class: COPROC_VX (slots 0,1,2,3)
                  Notes
                       ■  This may not work correctly in Napali V1.
80-N2040-44 Rev. B      MAY CONTAIN U.S. AND INTERNATIONAL EXPORT CONTROLLED INFORMATION                    230
Hexagon V67 Programmer’s Reference Manual                                                           Instruction Set
     11.1         ALU32
                  The ALU32 instruction class includes instructions which perform arithmetic and logical
                  operations on 32-bit data.
                  ALU32 instructions are executable on any slot.
    11.1.1        ALU32/ALU
                  The ALU32/ALU instruction subclass includes instructions which perform arithmetic and
                  logical operations on individual 32-bit items.
        Add
                  Add a source register either to another source register or to a signed 16-bit immediate
                  value. Store result in destination register. Source and destination registers are 32 bits. If the
                  result overflows 32 bits, it wraps around. Optionally saturate result to a signed value
                  between 0x80000000 and 0x7fffffff.
                  For 64-bit versions of this operation, see the XTYPE add instructions.
                   Syntax                                Behavior
                   Rd=add(Rs,#s16)                       apply_extension(#s);
                                                         Rd=Rs+#s;
                   Rd=add(Rs,Rt)                         Rd=Rs+Rt;
                   Rd=add(Rs,Rt):sat                     Rd=sat_32(Rs+Rt);
                  Class: ALU32 (slots 0,1,2,3)
                  Notes
                       ■   If saturation occurs during execution of this instruction (a result is clamped to
                           either maximum or minimum values), the OVF bit in the Status Register is set.
                           OVF remains set until explicitly cleared by a transfer to SR.
                  Intrinsics
                   Rd=add(Rs,#s16)                       Word32 Q6_R_add_RI(Word32 Rs, Word32 Is16)
                   Rd=add(Rs,Rt)                         Word32 Q6_R_add_RR(Word32 Rs, Word32 Rt)
                   Rd=add(Rs,Rt):sat                     Word32 Q6_R_add_RR_sat(Word32 Rs, Word32 Rt)
80-N2040-45 Rev. B                                                                                               169